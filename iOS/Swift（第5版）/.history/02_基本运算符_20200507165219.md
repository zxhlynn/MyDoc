# 基本运算符

## 基本运算符

运算符是检查、改变、合并值的特殊符号或组合符号。例如，加号( `+` )将两个数相加(如 `let i = 1 + 2` )。更复杂的运算例子包括逻辑与运算符 `&&` (如
`if enteredDoorCode && passedRetinaScan` )。

Swift 支持大部分标准 C 语言的运算符，并且为了减少常见编码错误做了部分改进。如：赋值（`=`）不再有返回值，这样就消除了手误将判等（`==`）写成赋值（`=`）导致代码错误的缺陷。算数运算符（`+`、`-`、`*`、`/`、`%`等）的结果会被检测并禁止值溢出，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时导致的异常。

Swift 还提供了 C 语言没有的区间运算符，例如`a..<b`或`a...b`，这方便我们表达一个区间内的数值。

## 术语

- 一元运算符对单一操作对象操作（如`-a`）。一元运算符分前置运算符和后置运算符，前置运算符需紧跟在操作对象之前（如`!b`），后置运算符需紧跟在操作对象之后（如`c!`）。

- 二元运算符操作两个操作对象（如`2+3`），是中置的，因为它们出现在两个操作对象之间。

- 三元运算符操作三个操作对象，只有一个就是三目运算符（`condition?value1:value2`）

受到运算符影响的值叫做`操作数`。在表达式`1 + 2`中，`+`符号是一个二元运算符，其中两个值`1`和`2`就是操作数。

## 赋值运算符

赋值运算符（`a=b`），表示用`b`的值来初始化或更新`a`的值：

```swift
let b = 10
var a = 5
a = b
// a 现在等于 10
```

如果赋值的右边是一个多个值的元组，它的元素可以马上被分解成多个常量或变量:

```swift
let (x, y) = (1, 2)
// 现在 x 等于 1，y 等于 2
```

与 C 语⾔和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以下⾯语句句是无效的:

```swift
if x = y {
  // 此句句错误，因为 x = y 并不不返回任何值
}
```

通过将 `if x = y` 标记为无效语句，Swift 能帮你避免把 ( `==` )错写成( `=` )这类错误的出现。

## 算术运算符

Swift 中所有数值类型都支持了基本的四则算术运算符:`+`,`-`,`*`,`/`

与 C 语⾔和 Objective-C 不同的是，Swift 默认情况下不允许在数值运算中出现值溢出的情况。但是 你可以使⽤ Swift 的溢出运算符来实现溢出运算(如 `a &+ b` )。

加法运算符也可用于`String`的拼接：`"hello"+"world"`

```swift
1 + 2
5 - 2
2 * 3
10.0 / 2.5
```

## 求余运算符

求余运算符( `a % b` )是计算 b 的多少倍刚好可以容⼊ a ，返回多出来的那部分(余数)。

> 求余运算符( % )在其他语⾔也叫取模运算符。但是严格说来，我们看该运算符对负数的操 作结果，「求余」⽐比「取模」更合适些。

## 一元负号运算符

数值的正负号可以使⽤用前缀 `-` (即一元负号符)来切换:

```swift
let three = 3
let minusThree = -three
let plusThree = -minusThree
// minusThree 等于 -3
// plusThree 等于 3, 或 "负负3"
```

一元负号符( `-` )写在操作数之前，中间没有空格。

## 一元正号运算符

一元正号符( `+` )不做任何改变地返回操作数的值:

```swift
let minusSix = -6
let alsoMinusSix = +minusSix
// alsoMinusSix 等于 -6
```

虽然一元正号符什什么都不不会改变，但当你在使⽤一元负号来表达负数时，你可以使⽤一元正号 来表达正数，如此你的代码会具有对称美。

## 自增运算自减运算

> swift 不再推荐使用自增自减运算符

## 组合赋值运算符

如同 C 语⾔言，Swift 也提供把其他运算符和赋值运算( `=` )组合的组合赋值运算符，组合加运 算( `+=` )是其中一个例子:

```swift
var a = 1
a += 2
// a 现在是 3
```

表达式 `a += 2` 是 `a = a + 2` 的简写，一个组合加运算就是把加法运算和赋值运算组合成进 一个运算符里，同时完成两个运算任务。

> 复合赋值运算没有返回值， let b = a += 2 这类代码是错误。这不同于上面提到的⾃自增和自减运算符。

## 比较运算符(Comparison Operators)

所有标准 C 语言中的比较运算符都可以在 Swift 中使⽤:

- 等于`==`
- 不等于`!=`
- 大于`>`
- 小于`<`
- 大于等于`>=`
- 小于等于`<=`
> Swift 也提供恒等( === )和不恒等( !== )这两个比较符来判断两个对象是否引⽤同一个对象实例。
- 恒等 `===`
- 不恒等`!==`

每个比较运算都返回了一个表示结果的布尔值（Bool）。比较运算多⽤于条件语句，如 if 条件:

```swift
let name = "world"
if name == "world" {
  print("hello, world")
} else {
  print("I'm sorry \(name), but I don't recognize you")
}
// 输出“hello, world", 因为 `name` 就是等于 "world”
```

如果两个元组的元素相同，且长度相同的话，元组就可以被比较。比较元组⼤小会按照从左到右、逐值比较的⽅式，直到发现有两个值不等时停⽌。如果所有的值都相等，那么这一对元组 我们就称它们是相等的。例如:

```swift
(1, "zebra") < (2, "apple") // true，因为 1 ⼩于 2
(3, "apple") < (3, "bird") // true，因为 3 等于 3，但是 apple ⼩小于 bird
(4, "dog") == (4, "dog") // true，因为 4 等于 4，dog 等于 dog
```

当元组中的元素都可以被比较时，你也可以使用这些运算符来⽐比较它们的⼤小。例如，像下⾯展示的代码，你可以⽐较两个类型为` (String, Int)` 的元组，因为 `Int` 和 `String` 类型 的值可以⽐比较。相反， `Bool` 不不能被⽐比较，也意味着存有布尔类型的元组不能被⽐较。

```swift
("blue", -1) < ("purple", 1) // 正常，⽐比较的结果为 true
("blue", false) < ("purple", true) // 错误，因为 < 不不能⽐比较布尔类型
```

> Swift 标准库只能⽐比较七个以内元素的元组⽐较函数。如果你的元组元素超过七个时，你需要 自己实现⽐较运算符。

## 三元运算符

三元运算符的特殊在于它是有三个操作数的运算符，它的形式是 `问题 ? 答案 1 : 答案 2` 。它简洁地表达根据问题成⽴与否作出⼆选一的操作。如果问题成立，返回 答案 1 的结果; 反之返回 答案 2

三元运算符是以下代码的缩写形式:

```swift
if question {
    answer1
} else {
    answer2
}
```

## 空合运算符(Nil Coalescing Operator)

空合运算符(` a ?? b `)将对可选类型 a 进⾏空判断，如果 a 包含一个值就进⾏解包，否 则就返回一个默认值 b 。表达式 a 必须是 Optional 类型。默认值 b 的类型必须要和 a 存储值的类型保持一致。

空合运算符是对以下代码的简短表达⽅法:

```swift
 a != nil ? a! : b
```

## 区间运算符

### 闭区间运算符

闭区间运算符( `a...b` )定义⼀一个包含从 a 到 b (包括 a 和 b )的所有值的区间。 a 的值不不能超过 b 。

闭区间运算符在迭代一个区间的所有值时是非常有⽤的，如在 for-in 循环中:

```swift
for index in 1...5 {
  print("\(index) * 5 = \(index * 5)")
}
```

### 半开区间运算符

半开区间运算符( `a ..< b` )定义一个从 a 到 b 但不不包括 b 的区间。 之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。

```swift
let names = ["Anna", "Alex", "Brian", "Jack"]
let count = names.count
for i in 0 ..< count {
  print("第 \(i + 1) 个⼈人叫 \(names[i])")
}
```

### 单侧区间

闭区间操作符有另一个表达形式，可以表达往一侧无限延伸的区间 —— 例如，一个包含了数组 从索引 2 到结尾的所有值的区间。在这些情况下，你可以省略掉区间操作符一侧的值。这种区间叫做单侧区间，因为操作符只有一侧有值。例如:

```swift
for name in names[2...] {
  print(name)
}
// Brian
// Jack
for name in names[...2] {
  print(name)
}
// Anna
// Alex
// Brian
```

半开区间操作符也有单侧表达形式，附带上它的最终值。就像你使用区间去包含一个值，最终值并不会落在区间内。例如:

```swift
for name in names[..<2] {
   print(name)
}
// Anna
// Alex
```

单侧区间不止可以在下标里使⽤，也可以在别的情境下使用。你不能遍历省略了初始值的单侧区间，因为遍历的开端并不明显。你可以遍历一个省略略最终值的单侧区间;然⽽，由于这种区间⽆限延伸的特性，请保证你在循环里有一个结束循环的分⽀。你也可以查看一个单侧区间是否包含某个特定的值，就像下⾯面展示的那样。

```swift
let range = ...5
range.contains(4) // true
```

### stride

`stride` 是 `Strideable` 协议中定义的一个方法， 它可以按照指定的递进值生成一个序列。可以用在 Swift 的循环语法结构中。

stride(from: <trideable#>, to: <#T##Strideable#>, by: <#T##Comparable & SignedNumeric#>)


## 逻辑运算符(Logical Operators)

- 逻辑非`!a`
- 逻辑与`a&&b`
- 逻辑或`a||b`

### 逻辑非运算符

逻辑⾮非运算符( `!a `)对一个布尔值取反，使得 `true` 变 `false` ， `false` 变 `true` 。它是一个前置运算符，需紧跟在操作数之前，且不加空格。读作 `非 a`。

### 逻辑与运算符

逻辑与运算符(` a && b `)表达了只有 a 和 b 的值都为 `true` 时，整个表达式的值才会是 `true` 。

### 逻辑或运算符

逻辑或运算符( `a || b` )是一个由两个连续的` | `组成的中置运算符。它表示了两个逻辑表 达式的其中一个为 `true` ，整个表达式就为 `true` 。

> 同逻辑与运算符类似，逻辑或也是「短路计算」的，当左端的表达式为 true 时，将不计算右边的表达式了，因为它不可能改变整个表达式的值了。